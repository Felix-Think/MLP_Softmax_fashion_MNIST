{"cmd": "\nimport torchvision\nimport torch\nfrom torchvision.datasets import FashionMNIST\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\n\n#|%%--%%| <VuTAK7n6Hd|Zn3XTTyha6>\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n\n#|%%--%%| <Zn3XTTyha6|n0uJvc03OB>\n\n# Load data\ntransform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(),\n                                            torchvision.transforms.Normalize((0.5,), (0.5,))])\ntrain_data = FashionMNIST(root = 'data',\n                          train = True,\n                          download = True,\n                          transform = transform)\ndata_loader = DataLoader(dataset = train_data, num_workers = 4, batch_size = 1024, shuffle = True)\n\ntest_data = FashionMNIST(root = 'data',\n                         train = False,\n                         download = True,\n                         transform = transform)\ntest_loader = DataLoader(dataset = test_data, num_workers = 4, batch_size = 1024, shuffle = True)\n\n\n# Print 1 image\nimage, label = train_data[0]\nprint(image.shape)\n\n#Define show image function\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef show_image(image):\n    image = image / 2.0 + 0.5\n    img = image.numpy()\n    img = np.transpose(img, (1, 2, 0))\n    plt.imshow(img, cmap = 'gray')\n    plt.show()\n\nfor i, (images, label) in enumerate(data_loader):\n    show_image(torchvision.utils.make_grid(images[:8]))\n    break\n\n#|%%--%%| <n0uJvc03OB|YTco5aW1i9>\n\n# Define model\nmodel = nn.Sequential(\n    nn.Flatten(),\n    nn.Linear(784, 256),\n    nn.ReLU(),\n    nn.Linear(256, 10)\n)\n\nmodel.to(device)\nprint(model)\n\n#|%%--%%| <YTco5aW1i9|0AkB01GvaC>\n\ninput_tensor = torch.randn(5, 28, 28).to(device)\noutput = model(input_tensor)\nprint(output.shape)\n\n\n#|%%--%%| <0AkB01GvaC|Wk1VQ6pvWN>\nr\"\"\"°°°\n# Define Loss, Optimizer, and evaluation function\n°°°\"\"\"\n#|%%--%%| <Wk1VQ6pvWN|yHJkbC7OLH>\n\n# Loss and optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr = 0.01)\n\n# Evaluation function\ndef evaluate(model, test_loader, criterion):\n    model.eval()\n    total = 0\n    correct = 0\n    test_loss = 0.0\n    with torch.no_grad():\n        for images, labels in test_loader:\n            images, labels = images.to(device), labels.to(device)\n            outputs = model(images)\n            loss = criterion(outputs, labels)\n            test_loss += loss.item()\n            _, predicted = torch.max(outputs.data, 1)\n            total += labels.size(0)\n            correct += (predicted == labels).sum().item()\n    accuracy = 100 * correct / total\n    test_loss = test_loss / len(test_loader)\n    return test_loss , accuracy\n\n\n#|%%--%%| <yHJkbC7OLH|kjnpUU0n5u>\n\ntest_loss ,accuracy = evaluate(model, test_loader, criterion)\nprint(f\"Test Loss: {test_loss:.4f}\")\nprint(f\"Accuracy: {accuracy:.2f}%\")\n\n\n\n\n#|%%--%%| <kjnpUU0n5u|xMsFpvWbAy>\nr\"\"\"°°°\n#Train model\n°°°\"\"\"\n#|%%--%%| <xMsFpvWbAy|lgehGX8kEb>\n\n#define paremeters\ntrain_loss = []\ntrain_accuracy = []\ntest_loss = []\ntest_accuracy = []\n\n# Train the model\nmax_epochs = 100\nfor epoch in range(max_epochs):\n    # Initialize some parameters\n    running_loss = 0.0\n    running_corrects = 0.0\n    total = 0\n    \n    for i, (images, labels) in enumerate(data_loader):\n        images, labels = images.to(device), labels.to(device)\n        \n        # Zero the parameter gradients\n        optimizer.zero_grad()\n\n        #Forward pass\n        outputs = model(images)\n        loss = criterion(outputs, labels)\n        running_loss += loss.item()\n\n        #Determine class predictions and accuracy\n\n        _, predicted = torch.max(outputs.data, 1)\n        running_corrects += (predicted == labels).sum().item()\n        total += labels.size(0)\n\n        # Backward and optimize\n        loss.backward()\n        optimizer.step()\n\n    epoch_accuracy = 100 * running_corrects / total\n    epoch_loss = running_loss / len(data_loader)\n    test_loss_epoch, test_accuracy_epoch = evaluate(model, test_loader, criterion)\n    print(f\"Epoch {epoch+1}/{max_epochs}, Train Loss: {epoch_loss:.4f}, Train Accuracy: {epoch_accuracy:.2f}%, Test Loss: {test_loss_epoch:.4f}, Test Accuracy: {test_accuracy_epoch:.2f}%\")\n    train_loss.append(epoch_loss)\n    train_accuracy.append(epoch_accuracy)\n    test_loss.append(test_loss_epoch)\n    test_accuracy.append(test_accuracy_epoch)\n\n#|%%--%%| <lgehGX8kEb|THp4pAElPV>\n\n# Plot loss and accuracy\nplt.plot(train_loss, label = 'train loss')\nplt.plot(test_loss, label = 'test loss')\nplt.legend()\nplt.show()\n\n#|%%--%%| <THp4pAElPV|26veYTqK8L>\n\nplt.plot(train_accuracy, label = 'train accuracy')\nplt.plot(test_accuracy, label = 'test accuracy')\nplt.legend()\nplt.show()\n", "outhist_cell": "B7UIq88rWy", "output_complete": 1, "outhist_title": "mATz5Ehb5z", "is_md": 0, "cmd_opts": " -s --md_cell_start=r\\\"\\\"\\\"°°°", "import_complete": 1, "terminal": "kitty"}